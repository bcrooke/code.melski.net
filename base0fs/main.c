/*
 * Copyright (c) 1997-2007 Erez Zadok <ezk@cs.stonybrook.edu>
 * Copyright (c) 2001-2007 Stony Brook University
 *
 * For specific licensing information, see the COPYING file distributed with
 * this package, or get one from
 * ftp://ftp.filesystems.org/pub/fistgen/COPYING.
 *
 * This Copyright notice must be kept intact and distributed with all
 * fistgen sources INCLUDING sources generated by fistgen.
 */
/*
 * File: fistgen/templates/Linux-2.6/main.c
 */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif /* HAVE_CONFIG_H */
#ifdef FISTGEN
# include "fist_base0fs.h"
#endif /* FISTGEN */
#include "fist.h"
#include "base0fs.h"
#include <linux/hash.h>
#include <linux/list.h>

dev_t sProcDev = 0;
dev_t sDevDev  = 0;


extern void base0fs_read_inode(inode_t *inode);

/* Older versions of Linux provide a trivial iget() function.  Newer versions
 * have dropped that, so we have created our own with equivalent
 * functionality.  Since the primatives that it uses exist on the older
 * versions, we just use our version across the board.
 */

struct inode *base0fs_iget(struct super_block *sb, unsigned long ino)
{
    struct inode *inode = iget_locked(sb, ino);
    if (inode && (inode->i_state & I_NEW)) {
        base0fs_read_inode(inode);
        unlock_new_inode(inode);
    }
    return inode;
}


/* sb we pass is base0fs's super_block */
int
base0fs_interpose(struct dentry *lower_dentry, struct dentry *dentry, super_block_t *sb, int flag)
{
        inode_t *lower_inode;
        int err = 0;
	inode_t *inode;

	print_entry_location();

	lower_inode = lower_dentry->d_inode; /* CPW: moved after print_entry_location */

	BUG_ON(!lower_inode);
	BUG_ON(dentry->d_inode != NULL);

	/*
	 * We allocate our new inode below, by calling iget.
	 * iget will call our read_inode which will initialize some
	 * of the new inode's fields
	 */

	/* check that the lower file system didn't cross a mount point */
	if (lower_inode->i_sb != SUPERBLOCK_TO_LOWER(sb)) {
		err = -EXDEV;
		goto out;
	}
	inode = base0fs_iget(sb, lower_inode->i_ino);

	if (!inode) {
		err = -EACCES;		/* should be impossible??? */
		goto out;
	}

	/*
	 * interpose the inode if not already interposed
	 * this is possible if the inode is being reused
	 * XXX: what happens if we get_empty_inode() but there's another already?
	 * for now, ASSERT() that this can't happen; fix later.
	 */
	if (INODE_TO_LOWER(inode) == NULL)
		INODE_TO_LOWER(inode) = igrab(lower_inode);

	/* Use different set of inode ops for symlinks & directories*/
	if (S_ISLNK(lower_inode->i_mode))
		inode->i_op = &base0fs_symlink_iops;
	else if (S_ISDIR(lower_inode->i_mode))
		inode->i_op = &base0fs_dir_iops;
        else
                inode->i_op = &base0fs_main_iops;

	/* Use different set of file ops for directories */
	if (S_ISDIR(lower_inode->i_mode))
		inode->i_fop = &base0fs_dir_fops;
        else 
                inode->i_fop = &base0fs_main_fops;


	/* properly initialize special inodes */
	if (S_ISBLK(lower_inode->i_mode) || S_ISCHR(lower_inode->i_mode) ||
            S_ISFIFO(lower_inode->i_mode) || S_ISSOCK(lower_inode->i_mode)) {
		init_special_inode(inode, lower_inode->i_mode, lower_inode->i_rdev);
	}

	/* Fix our inode's address operations to that of the lower inode */
	if (inode->i_mapping->a_ops != lower_inode->i_mapping->a_ops) {
		fist_dprint(7, "fixing inode 0x%p a_ops (0x%p -> 0x%p)\n",
                        inode, inode->i_mapping->a_ops,
                        lower_inode->i_mapping->a_ops);
		inode->i_mapping->a_ops = lower_inode->i_mapping->a_ops;
	}

	/* only (our) lookup wants to do a d_add */
	if (flag)
		d_add(dentry, inode);
	else
		d_instantiate(dentry, inode);

	BUG_ON(!DENTRY_TO_PRIVATE(dentry));

	/* all well, copy inode attributes */
	fist_copy_attr_all(inode, lower_inode);

out:
	print_exit_status(err);
	return err;
}


/* find lower dentry given this base0fs dentry */
struct dentry *
__base0fs_lower_dentry(const char *file, const char *func, int line, struct dentry *dentry)
{
	struct dentry *lower_dentry;

	BUG_ON(!dentry);
	BUG_ON(!dentry->d_op);
        BUG_ON(dentry->d_op != &base0fs_dops);

	BUG_ON(dentry->d_sb->s_op != &base0fs_sops);
        if (dentry->d_inode) {
                BUG_ON(dentry->d_inode->i_op != &base0fs_main_iops &&
                       dentry->d_inode->i_op != &base0fs_dir_iops &&
                       dentry->d_inode->i_op != &base0fs_symlink_iops);
        }
	lower_dentry = DENTRY_TO_LOWER(dentry);
	BUG_ON(!lower_dentry);
	return lower_dentry;
}


/*
 * Parse mount options: dir=XXX and debug=N
 *
 * Returns the dentry object of the lower-level (lower) directory;
 * We want to mount our stackable file system on top of that lower directory.
 *
 * Sets default debugging level to N, if any.
 */
int base0fs_parse_options(super_block_t *sb, char *options, struct dentry **lower_root, struct vfsmount **lower_mount)
{
	struct nameidata nd;
	char *name, *tmp, *end;
	int err = 0;
	int dir_specified = 0;

	print_entry_location();

        if (sProcDev == 0) {
            err = path_lookup("/proc", LOOKUP_FOLLOW, &nd);
            if (!err) {
                sProcDev = NAMEIDATA_TO_DENTRY(&nd)->d_inode->i_sb->s_dev;
            }
#ifdef NAMEIDATA_USES_STRUCT_PATH
            path_put(&nd.path);
#else
            dput(nd.dentry);
            mntput(nd.mnt);
#endif

            err = path_lookup("/dev", LOOKUP_FOLLOW, &nd);
            if (!err) {
                sDevDev = NAMEIDATA_TO_DENTRY(&nd)->d_inode->i_sb->s_dev;
            }
#ifdef NAMEIDATA_USES_STRUCT_PATH
            path_put(&nd.path);
#else
            dput(nd.dentry);
            mntput(nd.mnt);
#endif
        }

	/* We don't want to go off the end of our arguments later on. */
	for (end = options; *end; end++);

	while (options < end) {
		tmp = options;
		while (*tmp && *tmp != ',')
			tmp++;
		*tmp = '\0';
		if (!strncmp("dir=", options, 4)) {
			/* note: the name passed need not be encoded */
			name = options + 4;
			fist_dprint(4, "base0fs: using directory: %s\n", name);
			err = path_lookup(name, LOOKUP_FOLLOW, &nd);
			if (err) {
				printk("base0fs: error accessing lower directory '%s'\n", name);
				goto out;
			}
			*lower_root = NAMEIDATA_TO_DENTRY(&nd);
			*lower_mount = NAMEIDATA_TO_VFSMNT(&nd);
			fist_dprint(6, "parse_options: new s_root, inode: %p, %p\n",
                                    *lower_root, (*lower_root)->d_inode);
			dir_specified = 1;
		}
		else if (!strncmp("debug=", options, 6)) {
			int debug = simple_strtoul(options + 6, NULL, 0);
			fist_set_debug_value(debug);
		} else {
			printk(KERN_WARNING "base0fs: unrecognized option '%s'\n", options);
		}
		options = tmp + 1;
	}
	if (dir_specified != 1) {
		err = -EINVAL; /* dir option must be specified */
		printk("Please specify dir option\n");
	}

out:
	print_exit_location();
	return err;
}

#ifdef FIST_MALLOC_DEBUG
/* for malloc debugging */
static atomic_t base0fs_malloc_counter;

void *
base0fs_kmalloc(size_t len, int flag, int line, const char *file)
{
	void *ptr = (void *) kmalloc(len, flag);
	if (ptr) {
		atomic_inc(&base0fs_malloc_counter);
		printk("KM:%d:%p:%d:%s\n", 
                        (int) atomic_read(&base0fs_malloc_counter),
                        ptr, line, file);
	}
	return ptr;
}

void
base0fs_kfree(void *ptr, int line, const char *file)
{
	atomic_inc(&base0fs_malloc_counter);
	printk("KF:%d:%p:%d:%s\n", 
                (int) atomic_read(&base0fs_malloc_counter), ptr, line, file);
	kfree(ptr);
}
#endif /* FIST_MALLOC_DEBUG */




/* for attach mode, we use a different ->read_super() in attach.c */
static int
base0fs_read_super(super_block_t *sb, void *raw_data, int silent)
{
	struct dentry *lower_root = NULL;
	struct vfsmount *lower_mount = NULL;
	int err = 0;

	print_entry_location();

#ifdef FIST_MALLOC_DEBUG
	atomic_set(&base0fs_malloc_counter, 0); /* for malloc debugging */
#endif /* FIST_MALLOC_DEBUG */

	if (!raw_data) {
		printk(KERN_WARNING "base0fs_read_super: missing data argument\n");
		err = -EINVAL;
		goto out_no_raw;
	}
	/*
	 * Allocate superblock private data
	 */
	SUPERBLOCK_TO_PRIVATE_SM(sb) = KMALLOC(sizeof(struct base0fs_sb_info), GFP_KERNEL);
	if (!SUPERBLOCK_TO_PRIVATE(sb)) {
		printk(KERN_WARNING "%s: out of memory\n", __FUNCTION__);
		err = -ENOMEM;
		goto out;
	}
	memset(SUPERBLOCK_TO_PRIVATE(sb), 0, sizeof(struct base0fs_sb_info));


	if ((err = base0fs_parse_options(sb, raw_data, &lower_root, &lower_mount))) {
		goto out_free;
	}
	if (IS_ERR(lower_root)) {
		printk(KERN_WARNING "base0fs_read_super: lookup_dentry failed (err = %ld)\n", PTR_ERR(lower_root));
		err = PTR_ERR(lower_root);
		goto out_free;
	}
	if (!lower_root->d_inode) {
		printk(KERN_WARNING "base0fs_read_super: no directory to interpose on\n");
		goto out_dput;
	}
	SUPERBLOCK_TO_LOWER(sb) = lower_root->d_sb;

	sb->s_maxbytes = lower_root->d_sb->s_maxbytes;

	sb->s_op = &base0fs_sops;
#if defined(HAVE_ADDRESS_SPACE_OPS_EXT)
        sb->s_flags |= MS_HAS_NEW_AOPS;
#endif

	/*
	 * we can't use d_alloc_root if we want to use
	 * our own interpose function unchanged,
	 * so we simply replicate *most* of the code in d_alloc_root here
	 */

	sb->s_root = d_alloc(NULL, &(const struct qstr){hash: 0, name: "/", len: 1});
        if (IS_ERR(sb->s_root)) {
		printk(KERN_WARNING "base0fs_read_super: d_alloc failed\n");
		err = -ENOMEM;
		goto out_dput;
	}

	sb->s_root->d_op = &base0fs_dops;
	sb->s_root->d_sb = sb;
	sb->s_root->d_parent = sb->s_root;
	/* link the upper and lower dentries */
	DENTRY_TO_PRIVATE_SM(sb->s_root) = (struct base0fs_dentry_info *) KMALLOC(sizeof(struct base0fs_dentry_info), GFP_KERNEL);

	if (!DENTRY_TO_PRIVATE(sb->s_root)) {
		err = -ENOMEM;
		goto out_dput2;
	}
	DENTRY_TO_LOWER(sb->s_root) = lower_root;
	DENTRY_TO_LVFSMNT(sb->s_root) = lower_mount;


	if ((err = base0fs_interpose(lower_root, sb->s_root, sb, 0)) != 0)
		goto out_dput2;

	fist_print_dentry("base0fs_read_super OUT lower_dentry", lower_root);
	fist_print_inode("base0fs_read_super OUT lower_inode", lower_root->d_inode);
	// next line causes null ptr deref at mount(2) time
	// fist_print_dentry("%s OUT sb->s_root", __FUNCTION__, sb->s_root);
	goto out;

out_dput2:
	dput(sb->s_root);
out_dput:
	dput(lower_root);
out_free:
	// XXX: HL: is that mntput necessary? There is some relation to the path_walk in parse_options -
	//  there the path_release is "missing"
	mntput(lower_mount);
	KFREE(SUPERBLOCK_TO_PRIVATE(sb));
	SUPERBLOCK_TO_PRIVATE_SM(sb) = NULL;
out:
	fist_print_sb("OUT sb", sb);
	if (SUPERBLOCK_TO_PRIVATE(sb))
		fist_print_sb("OUT lower_sb", SUPERBLOCK_TO_LOWER(sb));
out_no_raw:
	print_exit_location();
	return err;
}



#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
static struct super_block *base0fs_get_sb(struct file_system_type *fs_type,
                                         int flags, const char *dev_name,
                                         void *raw_data)
{

	return get_sb_nodev( fs_type, flags, raw_data, base0fs_read_super );
}
#else
static int base0fs_get_sb(struct file_system_type *fs_type,
                                         int flags, const char *dev_name,
                                         void *raw_data, struct vfsmount *mnt)
{

	return get_sb_nodev( fs_type, flags, raw_data, base0fs_read_super, mnt );
}
#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18) */

void base0fs_kill_block_super(struct super_block *sb)
{
	generic_shutdown_super(sb);
/*
 *	XXX: BUG: Halcrow: Things get unstable sometime after this point:
 *
 *	lib/rwsem-spinlock.c:127: spin_is_locked on uninitialized
 *	spinlock a1c953d8.
 *
 *	fs/fs-writeback.c:402: spin_lock(fs/super.c:a0381828) already
 *	locked by fs/fs-writeback.c/402
 *
 *	Apparently, someone's not releasing a lock on sb_lock...
*/
}

static struct file_system_type base0fs_fs_type = {
	.owner          = THIS_MODULE,
	.name           = "base0fs",
	.get_sb         = base0fs_get_sb,
	.kill_sb        = base0fs_kill_block_super,
	.fs_flags       = 0,
};

static int __init init_base0fs_fs(void)
{
        int err;
	printk("Registering base0fs version $Id: main.c,v 1.33 2007/11/30 15:29:55 ezk Exp $\n");
        err = base0fs_init_inodecache();
        if (err)
                goto out1;
	err = register_filesystem(&base0fs_fs_type);
        if (err)
                goto out;
        return 0;
out:
        base0fs_destroy_inodecache();
out1:
        return err;
}
static void __exit exit_base0fs_fs(void)
{
	printk("Unregistering base0fs version $Id: main.c,v 1.33 2007/11/30 15:29:55 ezk Exp $\n");
        base0fs_destroy_inodecache();

	unregister_filesystem(&base0fs_fs_type);
}

MODULE_AUTHOR("Erez Zadok <ezk@cs.sunysb.edu>");
MODULE_DESCRIPTION("FiST-generated base0fs filesystem");

/*
 * Note: you must define *some* non-empty license string in your .fist file,
 * using the "license" declaration.  It's up to the author to decide what
 * they want: it can be anything.  But if on Linux you pick something other
 * than the approved licenses as listed in <linux/module.h>, your module may
 * not link into the kernel if it's using GPL-only symbols.  For more
 * information, see the COPYING file which should be in the same directory
 * you found this file in.
 */
/* This definition must only appear after we include <linux/module.h> */
MODULE_LICENSE("GPL");	/* defined via "license" decl in .fist file */
#ifndef MODULE_LICENSE
# error must define module license via fistgen license declaration
#endif /* not MODULE_LICENSE */

module_param(fist_debug_var, int, 0644);
MODULE_PARM_DESC(fist_debug_var, "Debug level");

module_init(init_base0fs_fs)
module_exit(exit_base0fs_fs)

/*
 * Local variables:
 * c-basic-offset: 4
 * End:
 */
